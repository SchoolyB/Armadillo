module cli

import @std, @strings
import "../core"
import lib"../library"


do check_if_valid_key(providedK string) -> bool {
    if providedK not_in lib.VALID_KEYS {
        return false
    }

    return true
}

do check_if_valid_operation(providedO string) -> bool {
    if providedO not_in lib.VALID_OPERATIONS{
        return false
    }

    return true
}

do make_new_command(parsedInput [string]) -> lib.Command{
    temp c = new(lib.Command)
    if len(parsedInput) == 2 {
        if !check_if_valid_key(parsedInput[0]) {
              temp keys = lib.VALID_KEYS
            for_each vk in keys {
                std.println(vk)
            }

            return c
        }

        if !check_if_valid_operation(parsedInput[1]) {
            for_each vc in lib.VALID_OPERATIONS {
                std.println(vc)
            }

            return c
        }

        c.keyToken = parsedInput[0]
        c.operationToken = parsedInput[1]
        c.hasTarget = false

    } or len(parsedInput) == 3 {
        if !check_if_valid_key(parsedInput[0]) {
            for_each vk in lib.VALID_KEYS {
                std.println(vk)
            }

            return c
        }

        if !check_if_valid_operation(parsedInput[1]) {
            for_each vc in lib.VALID_OPERATIONS {
            std.println(vc)
        }

            return c
        }

        //TODO: need to validate target in the future
        c.keyToken = parsedInput[0]
        c.operationToken = parsedInput[1]
        c.hasTarget = true
        c.targetToken = parsedInput[2]

    } otherwise {
        std.println("ERROR: Wrong number of command line arguments provided. Expected: 2-3. Got: ${len(parsedInput)}")
        return c
    }

    return copy(c)
}


do get_and_parse_input() -> [string] {
    return strings.split(input(), " ")
}

do command_line(&cpu lib.CPU, command lib.Command) -> int {

    when command.operationToken{
        is lib.VALID_OPERATIONS[0] { //run
            core.parse_assembly_lines(command.targetToken)
            temp asm = core.assemble(command.targetToken)
            temp _ = core.run(asm, cpu)
        }

        is lib.VALID_OPERATIONS[1] { //asm
            temp result = core.assemble(command.targetToken)
            std.println("Assembled Content of file ${command.targetToken}: ")
            std.println(result)
        }
        default{
            std.println("Invalid operation. Valid operations are: ")
            temp count uint = 0
            for_each op in lib.VALID_OPERATIONS{
                count += 1
                std.println("${count}.${op}")
            }
            std.println()
        }
    }

    return 0
}