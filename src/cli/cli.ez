module cli

import @std, @strings
import "../core"
import lib"../library"


do check_if_valid_key(providedK string) -> bool {
    if providedK not_in lib.validKeys {
        return false
    }

    return true
}

do check_if_valid_operation(providedO string) -> bool {
    if providedO not_in lib.validOperations{
        return false
    }

    return true
}

do make_new_command(parsedInput [string]) -> lib.Command{
    temp c = new(lib.Command)
    if len(parsedInput) == 2 {
        if !check_if_valid_key(parsedInput[0]) {
            std.println("ERROR: Invalid Key Provided")
            std.println("Valid keys are: ")
              temp keys = lib.validKeys
            for_each vk in keys {
                std.println(vk)
            }

            return c
        }

        if !check_if_valid_operation(parsedInput[1]) {
            std.println("ERROR: Invalid operation Provided ${parsedInput[1]}")
            std.println("Valid operations are: ")
            for_each vc in lib.validOperations {
                std.println(vc)
            }

            return c
        }

        c.keyToken = parsedInput[0]
        c.operationToken = parsedInput[1]
        c.hasTarget = false

    } or len(parsedInput) == 3 {
        if !check_if_valid_key(parsedInput[0]) {
            std.println("ERROR: Invalid Key Provided")
            std.println("Valid keys are: ")
            for_each vk in lib.validKeys {
                std.println(vk)
            }

            return c
        }

        if !check_if_valid_operation(parsedInput[1]) {
            std.println("ERROR: Invalid operation Provided ${parsedInput[1]}")
            std.println("Valid operations are: ")
            for_each vc in lib.validOperations {
            std.println(vc)
        }

            return c
        }

        //TODO: need to validate target in the future
        c.keyToken = parsedInput[0]
        c.operationToken = parsedInput[1]
        c.hasTarget = true
        c.targetToken = parsedInput[2]

    } otherwise {
        std.println("ERROR: Wrong number of command line arguments provided. Expected: 2-3. Got: ${len(parsedInput)}")
        return c
    }


    return copy(c)
}


do get_and_parse_input() -> [string] {
    temp inputArr [string] = strings.split(input(), " ")
    //std.println(inputArr)

    return inputArr
}

do command_line(&cpu lib.CPU, command lib.Command) -> int {

    when command.operationToken{
        is lib.validOperations[0] { //run
            core.parse_assembly_lines(command.targetToken)
            temp asm = core.assemble(command.targetToken)
            temp _ = core.run(asm, cpu)
        }

        is lib.validOperations[1] { //asm
            temp result = core.assemble(command.targetToken)
            std.println(result)
        }
        default{
            std.println("Something else")
        }

    }

    return 0
}
