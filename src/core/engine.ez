module core

import @std, @arrays
import lib"../library"

do init_cpu() -> lib.CPU {
    temp cpu = new(lib.CPU)
    temp initMem [byte] = {0,0,0,0,0,0,0,0}

    cpu.architecture = lib.ARCHITECTURE
    cpu.memory = initMem
    cpu.registers = make_registers()
    cpu.pc = 0
    cpu.isRunning = true

    return copy(cpu)
}

//'Dynamically' creates an array of registers for the CPU.
// made it dynamic in the event i add more registers in the future.
do make_registers() -> [byte] {
    temp registerArray [byte]

    for i in range(0, lib.REGISTER_MAX_AMOUNT){
        temp register byte = 0
        arrays.append(registerArray, register)
    }

    return registerArray
}

//run passed in asm8 instructions
do run(instructions [[byte]], &cpu lib.CPU) -> int {
    for_each instruction in instructions {
        temp decoded = decode_instructions(instruction)
        std.println(decoded.opCode)
        when int(decoded.opCode) {
            is 0 {
                std.println("STOP INSTRUCTION ENCOUNTERED...STOPPING")
                return 0
            }
            is 1 { //LOAD value into register
                cpu.registers[int(decoded.register)] = decoded.value
            }
            is 2 { //STORE register into memory
                cpu.memory[int(decoded.value)] = cpu.registers[int(decoded.register)]
            }
            default {std.println("Defaulting")}
        }
    }

    return 0
}